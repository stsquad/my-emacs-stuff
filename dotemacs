; -*- emacs-lisp -*-
;
; Alex Bennee's .emacs
;
; This is my .emacs. It is mainly an amalgem of different hacks
; acquired over time which I use on many of the machines I work with.
;
; It has a cobbled heritage from various sites and wiki's and its
; probably safest to assume the code is all either GPL or Public
; Domain. Feel free to use whatever bits may be of use to you in this
; file that it is my right to license ;-)
;

(message ".emacs Start")

(setq debug-on-error t)

;;;; Start of real code.

;;; Basic sanity
;; Find out about my environment
;; Tweak a few paths

; This is ugly, but at the current release rate we shouldn't have more
; than 3 or 4 potential emacsen on a box
(defvar I-am-emacs-21 (string-match "GNU Emacs 21" (emacs-version)))
(defvar I-am-emacs-22 (string-match "GNU Emacs 22" (emacs-version)))
(defvar I-am-emacs-23 (string-match "GNU Emacs 23" (emacs-version)))

(defvar I-am-emacs-21+ (or I-am-emacs-21 I-am-emacs-22 I-am-emacs-23))
(defvar I-am-emacs-22+ (or I-am-emacs-22 I-am-emacs-23))

(defvar I-am-xemacs (string-match "XEmacs" (emacs-version)))

;; Lets define which machine I'm on, therefor if I am at work
;; (this of course falls down when logging on remotely via tramp)

(defvar I-am-at-work (string-match "transitives" (system-name)))
(defvar I-am-at-home (string-match "malory" (system-name)))
 
;;
;; Lets set some paramters if we are running as a console or under X
;;
;; Why not use window-system? Well the rest of the likes simple bool tests
;;
(defvar I-am-in-X (eval 'window-system));
(defvar I-am-in-console (not (eval 'window-system)))

;; Autoloads
;? Put them near their configuration.
;? Check that extended modes are available.

;(if (locate-library "msb")
;    (progn
;      (autoload 'msb-mode "msb" "Fancier buffer-selection menu" t)
;      ;; fancier buffer menu
;      (setq buffers-menu-max-size nil) ; Don't think this is needed with msb
;      (msb-mode 1)))

;; Default mode is text-mode,
(setq default-major-mode 'text-mode)

;; Don't truncate message buffer. For debugging reasons.
(setq message-log-max t)

;; Less verbosity
(fset 'yes-or-no-p 'y-or-n-p)

;; Obey local variables set in -*- type things
(setq enable-local-variables t)

;; Silently add trailing newline to file
(setq require-final-newline t)

;; ^K deletes line, not delete to EOL
(setq-default kill-whole-line t)

;; Searches are case sensitive
(setq-default case-fold-search nil)

;; Automagically decompress files

(unless I-am-xemacs
  (auto-compression-mode))

;; Change menu entry so it doesn't use faces.
(define-key global-map [menu-bar tools print ps-print-buffer]
  '("Postscript Print Buffer" . ps-print-buffer))

;; Add local search path
;
; This is recursive so adding test libraries should be a case of
; throwing the directory into .emacs.d
;
(when (file-exists-p "~/.emacs.d/")
  (if (fboundp 'normal-top-level-add-subdirs-to-load-path)
      (let* ((my-lisp-dir "~/.emacs.d/")
	     (default-directory my-lisp-dir))
	(setq load-path (cons my-lisp-dir load-path))
	(normal-top-level-add-subdirs-to-load-path))))

;;  (message "Adding local .emacs.d to lib path")
;;  (add-to-list 'load-path "~/.emacs.d/"))

(message "Done Basic Sanity")


;;; Miscellaneous functions

; I like my name
(defun insert-myname ()
  (interactive)
  (insert (format "Alex Bennée")))

(global-set-key (kbd "C-M-e") 'insert-myname)


(defun praise-emacs ()
  (interactive)
  (message "Basking in the glory of your praise...")
  (sleep-for 1)
  (message "Basking in the glory of your praise...Done."))

;;
;; Need a better way to do this as fortune is on different places
;; on different machines.
;;
(defun fortune ()
  "Famous unix fortune teller."
  (shell-command-to-string "/usr/bin/fortune"))

;(fortune)

(defun my-kill-line ()
  "Iain's hack to make kill-line work even when you're in the middle of one."
  (interactive)
  (beginning-of-line)
  (call-interactively 'kill-line))


;; String munging functions
;
; Extract the first group in a regex

(defun extract-string(regex string)
  "Extract a string in a regex (the bit in ()'s)"
  (interactive)
  (let ((s string)) (if (string-match regex s) (match-string 1 s) s)))

; chomp
(defun chomp(string)
  "Perform a perl-like chomp"
  (let ((s string)) (if (string-match "\\(.*\\)\n" s) (match-string 1 s) s)))

;
; example:
;(extract-string "name is \\(\.*\\) " "my name is Alex ok")
;
; extracts "Alex"

;; which-lookup
;
; Like the shell command of the same name except it trims to 'nil if
; it can't find anything

(defun which-lookup(name)
  "Perform a `which` like file look-up"
  (let
      ((file (chomp (shell-command-to-string (concat "which " name)))))
    (if (file-exists-p file)
	(concat file)
      ())))
       
; (which-lookup "foo") => nil
; (which-lookup "ispell") => "/usr/bin/ispell"

;; Define a current-project-root
;
; In most cases I open emacs at the top of a src tree. Searches and compiles
; can then use this as a starting point
;
; change with (setq current-project-root (chomp (shell-command-to-string "pwd")))
(defvar current-project-root
  (concat (chomp (shell-command-to-string "pwd")))
  "Describes the current project root dir (top of src tree)")

(defun set-project-root ()
  "Set a primary project root"
  (interactive)
  (setq current-project-root
	(read-file-name "Project Root:")))

;; secondary-project-root
;
; Sometimes your working with two source trees. The secondary tree is
; tracked and useful for bringing up ediff's and the like
;

(defvar secondary-project-root
  ()
  "Describes a secondary project root (say for quick ediff)")

(defun set-secondary-root ()
  "Set a secondary project root"
  (interactive)
  (setq secondary-project-root
	(read-file-name "Secondary Project Root:")))

(defun set-secondary-root-if-not ()
  "Check is secondary-project-root is defined, if not set it"
  (if (not secondary-project-root)
      (set-secondary-root)))

;; Find methods
;
; Define various find methods for searching through code/whatever and
; presenting the results in a buffer that can be navigated in emacs. It uses
; the existing grep-find mechanics but extends it.
;

(defun my-grep-find (root files search)
  (grep-find (concat "find " root files " -print0 |  xargs -0 -e grep -n -e " search)))

; define the find search strings (note excessive escapeage of ('s)
(defvar find-c-files
  (concat " \\( -iname '*.[chS]' -or -iname '*.cc' -or -iname '*.cpp' \\) ")
  "Search string for C/C++ files")

(defvar find-perl-files
  (concat " \\( -iname '*.pl' -or -iname '*.pm' \\) ")
  "Search string for Perl files")

(defvar find-lisp-files
  (concat " \\( -iname '*.el' \\) ")
  "Search string for Lisp Files")

;
; my-find
;
; Need to improve to be context sensative
;
(defun my-find (search)
  "A search from the current-project-root"
  (interactive "sSearch string:")
  (my-grep-find current-project-root find-c-files search))

; my-find-files (find a file name from project root)
;
; exteneds fine-name-dired to use project root

;(defun my-find-files (filespec)
;  (interactive "sSearch file:")
;  (grep-find (concat "find " current-project-root " -iname '" filespec "*' -printf '%p:0:\n'")))

(defun my-find-files (filespec)
   (interactive "sSearch for filespec:")
   (find-name-dired current-project-root filespec))

(global-set-key (kbd "<f6>") 'my-find-files)

(message "Done defuns")

;;; keymapping
;;
;; I'm allowed to bind: C-c [letter], [f5]-[f9]
;;
;; NB I've also re-mapped Caps-Lock to control

;; Goto-line should be easy
(global-set-key "\C-cg" 'goto-line)
(global-set-key "\M-g" 'goto-line)

;; Return => newline-and-indent
(global-unset-key "\C-m")
(global-set-key "\C-m" 'newline-and-indent)

;; Make delete do what I expect
;? Do I still need this?
(global-unset-key [delete])
(global-set-key [delete] 'delete-char)

;; C-k deletes whole line
(global-unset-key "\C-k")
(global-set-key "\C-k" 'my-kill-line)

;; Let's also do Alt-X and easier way
(global-set-key "\C-x\C-m" 'execute-extended-command)
(global-set-key "\C-c\C-m" 'execute-extended-command)

;; The default window size keys are silly
(global-set-key (kbd "<M-down>") 'enlarge-window)
(global-set-key (kbd "<M-up>") 'shrink-window)

;; In Emacs 21+, home and end go to beginning and end of line. This is
;; clearly the Wrong Thing.
(if I-am-emacs-21+
    (progn ()
	   (global-unset-key [home])
	   (global-set-key [home] 'beginning-of-buffer)
	   (global-unset-key [end])
	   (global-set-key [end] 'end-of-buffer)))

(message "Done keymapping")

;;; Backup settings
;;
;; I like to use symbolic links for a lot of my ~/bin scripts to my
;; working dir. By default these get broken when emacs writes a new
;; file.

(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.saves"))   ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups


(message "Setting up display")
;;; Display hacks

;; Set the frame size to larger if on a Graphics display (we tell by
;; looking at colour cells (must fix to not break emacs20, maybe)
;(current-frame-configuration)
(if I-am-in-X
  (if I-am-at-work
      (progn
	(setq default-frame-alist '((top . 0)
				    (left . 0)
				    ;; (left . 1300) ; right hand monitor
				    (width . 120)
				    (height . 50)
				    (background-color . "DarkSlateGrey")
				    (foreground-color . "wheat")
				    (vertical-scroll-bars . right)
				    (tool-bar-lines . nil))))
    ; smaller screen at home
    (progn
      (setq default-frame-alist '((top . 0)
				  (left . 0)
				  (width . 120)
				  (height . 50)
				  (background-color . "DarkSlateGrey")
				  (foreground-color . "wheat")
				  (vertical-scroll-bars . right)
				  (tool-bar-lines . nil))))))

;; Create new frame
;
; This is a hack to get around the fact that default-frame-alist
; won't take effect until new frames get created (or so I thought, it
; appears to take effect right away now!

;(if I-am-in-X
;    (progn
;      (new-frame)
;      (delete-frame)
;      (message "done frame switch")))

(message "Display Done")


;; Prettier unique buffer names.
(unless I-am-xemacs
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))

;; Stop the mouse cursor getting in the way. This is great.
(unless I-am-xemacs
  (if 'window-system
    (mouse-avoidance-mode 'exile)))

;; Change the cursor colour in Ovwrt mode
(defun ins-cursor-set ()
  "Set cursor colour according to insert mode"
  (set-cursor-color
   (if overwrite-mode
       "red"
     "black")))

(if I-am-emacs-21+
    (blink-cursor-mode -1))

(add-hook 'post-command-hook 'ins-cursor-set)

(setq frame-title-format "%b")
(setq  icon-title-format "%b")

;(if I-am-emacs-21
;    (progn 
;      (autoload 'zone-when-idle "zone")
;      (zone-when-idle 60)))

;; want to reduce the amount of white space in the mode-line
(setq default-mode-line-format
      '("-"
	mode-line-mule-info
	mode-line-modified
	" "
	mode-line-buffer-identification
	" "
	global-mode-string
	"%[("
	mode-name
	mode-line-process
	minor-mode-alist
	"%n"
	")%]-"
	(line-number-mode "L%l-")
	(column-number-mode "C%c-")
	(which-func-mode ("" which-func-format))
	"-%-"))

;; Let's shrink the minor-mode-alist down to size.
(setcdr (assq 'abbrev-mode minor-mode-alist) '(" Ab"))
(setcdr (assq 'auto-fill-function minor-mode-alist) '(" Fl"))

;; Not added until the relevant mode is loaded.
(setq minor-mode-alist (cons '(compilation-in-progress nil)
				 minor-mode-alist))

;; Uses a separate variable. Isn't that nice?
(setq eldoc-minor-mode-string nil
      highlight-changes-passive-string nil)

;; (display-time) is needed for appt to display in the mode-line, but
;; we don't want the time taking up precious space.
(unless I-am-xemacs
  (setq display-time-24hr-format t
      display-time-interval    20
      display-time-format "")
  (display-time))

;; Displays current function() in programming modes. 
(setq which-func-modes t
      which-func-format '("[" which-func-current "]-"))
(which-func-mode)

;; Reduce white space
(setq-default mode-line-buffer-identification '("%b"))

;; Make fill do the Right Thing with full-stops.
(setq sentence-end-double-space nil)

;; Highlights region _all_ the time. Slightly buggy...
(transient-mark-mode t)
(delete-selection-mode 1)

;; Groovy things with matching parentheses
(show-paren-mode t)

;; Tweaks to scrolling behaviour. Still a bit odd.
(setq scroll-preserve-screen-position t
      scroll-conservatively 5
      scroll-step 1
      next-line-add-newlines nil)

;; Make pound signs work
(set-language-environment "Latin-1")
(setq unibyte-display-via-language-environment t)

;; Allow narrowing.
(put 'narrow-to-region 'disabled nil)

(message "Done Display Hacks")


;;; Minor modes
;; Highlight changes.
;? Timer-based M-x highlight-changes-rotate-face

(if I-am-emacs-22+
    (setq highlight-changes-colors '("red1" "red2" "red3" "red4"))
  (setq highlight-changes-colours '("red1" "red2" "red3" "red4")))

(global-highlight-changes 'passive)

;; Problem is, this only appears to work when h-c-m is 'active. And it
;; sort of clashes with font-lock then.
(add-hook 'highlight-changes-enable-hook
	  '(lambda ()
	     (add-hook 
	      'local-write-file-hooks 'highlight-changes-rotate-faces)))

(add-hook 'highlight-changes-disable-hook
	  '(lambda ()
	     (remove-hook 
	      'local-write-file-hooks 'highlight-changes-rotate-faces)))

;; Expands a time-stamp line
(setq time-stamp-format "%02H:%02M on %:a, %:d %:b %:y by %u")
(add-hook 'write-file-hooks 'time-stamp)

;; Auto-Insert
(auto-insert-mode 1)
(setq auto-insert-alist ())		;? html-helper

;; Speedbar (not that I use it much)
(add-hook 'speedbar-load-hook
	  '(lambda ()
	     (setq speedbar-update-speed 5
		   speedbar-track-mouse-flag t
		   speedbar-activity-change-focus t)))

;; Bow down before font-lock
(add-hook 'font-lock-mode-hook
	  '(lambda ()
	     (setq font-lock-maximum-decoration  t
		   font-lock-verbose             t
		   font-lock-support-mode        'jit-lock-mode
		   lazy-lock-defer-on-scrolling  nil
		   lazy-lock-defer-contextually  t
		   lazy-lock-stealth-verbose     t
		   lazy-lock-stealth-lines       50
		   lazy-lock-stealth-time        3)))
(global-font-lock-mode t)

;; Calendar / Diary stuff.

(if I-am-at-work
    (progn
      (setq calendar-latitude  53.4834
	calendar-longitude     -2.2466
	calendar-location-name "Manchester City Center")))


;; Font locking info mode (from Andy.Ling@quantel.com)
(defvar info-font-lock-keywords
  (list
   '("^\\* [^:]+:+" . font-lock-function-name-face)
   '("\\*[Nn]ote\\b[^:]+:+" . font-lock-reference-face)
   '("  \\(Next\\|Prev\\|Up\\):" . font-lock-reference-face))
  "Additional expressions to highlight in Info mode")

(add-hook 'Info-mode-hook
	  (lambda ()
	    (make-local-variable 'font-lock-defaults)
	    (setq
	          font-lock-defaults '(info-font-lock-keywords nil t)
		  case-fold-search nil)))

;; ediff
;
; Need to setup properly
;
;? Also need to find a way to restore it all on
;  resume. This stuff is all far from bullet-proof.

(if (locate-library "ediff")
    (progn

      (defun do-ediff-cusomisations ()
	"Set up my ediff customisations"
	(setq diff-switches               "-u"
	      ediff-custom-diff-options   "-U3"
	      ediff-split-window-function 'split-window-horizontally
	      ediff-window-setup-function 'ediff-setup-windows-plain
	      ediff-use-last-dir          t)

	(add-hook 'ediff-startup-hook 'ediff-toggle-wide-display)
	(add-hook 'ediff-cleanup-hook 'ediff-toggle-wide-display)
	(add-hook 'ediff-suspend-hook 'ediff-toggle-wide-display))

      (autoload 'ediff-files "ediff");
      (autoload 'ediff-buffers "ediff");

      ;; my-ediff-secondary
      ;
      ; See if we can find the equivilent file in a secondary project root
      ; and bring up ediff on it.

      (defun my-ediff-secondary ()
	"Load the secondary equivilent file of this buffer and ediff it"
	(interactive)
	; ensure customisations have run
	(do-ediff-cusomisations)
					; sanity
	(set-secondary-root-if-not)
	(message (concat "buffer name is " (buffer-file-name)))
	(let
	    (
	     (primary-buffer (buffer-file-name))
	     (secondary-buffer (replace-regexp-in-string
				current-project-root secondary-project-root
				(buffer-file-name))))
					; sanity
	  (if (file-exists-p secondary-buffer)
	      (ediff-files secondary-buffer primary-buffer)
	    (ediff-files (read-file-name
			  (concat "Whats the path to " buffer-file-name))
			 primary-buffer))))

      (message "Done ediff customisations")))

;; ediff-trees
;
; This is another library that does a tree view approach
(if (locate-library "ediff-trees")
    (autoload 'ediff-trees "ediff-trees" "Start an tree ediff" t))

;      (load-library "ediff-trees")))


;; diff-mode and its derivitives
;
; Here we have some tweaks to the diff-mode for testing a series of
; patchs and/or applying a whole patch
;

(if (locate-library "diff-mode")
    (progn
      (if (locate-library "my-diff-mode")
	  (progn
	    (autoload 'my-diff-mode "my-diff-mode")
	    (defalias 'dmode-alias 'my-diff-mode))
	(autoload 'diff-mode "diff-mode")
	(defalias 'dmode-alias 'diff-mode))

      ; Which ever version we have we need to set the
      ; automode up so it loads when we need it
      (setq auto-mode-alist (append (list
				     (cons "\\.diff\\'"  'dmode-alias)
				     (cons "\\.patch\\'" 'dmode-alias)
				     (cons "0.*.txt" 'dmode-alias)
				     (cons ".dotest/0.*"
					   'dmode-alias))
				    auto-mode-alist))))
;; ispell
;
; There should be an easier way to set the default
; however I'm currently setting each time a file
; is opened using the find-file-hooks
;
; Also if I'm on a odd machine I'll skip it as they have the ispell.el
; library but not the actual ispell program
;
; And I want to use aspell by default as more people have that (and it
; should be better right?)
;

; I'm British, not Amercian damit!
;(defun set-british-dict ()
;  "Set British Dictionary"
;  (ispell-change-dictionary "british")
;  (message "Set ispell to British Dictionary"))

;(defun my-text-mode-hook ()
;  (set-british-dict)
;  (define-key text-mode-map (kbd "<f1>") ispell-word))

(if (locate-library "ispell")
    (progn
      (let (
	    (ispell-path (which-lookup "ispell"))
	    (aspell-path (which-lookup "aspell")))
	(message "Doing ispell dict setting")
	(if (or ispell-path aspell-path)
	    (progn
					; select aspell out of preference
	      (if (eval aspell-path)
		  (setq ispell-program-name "aspell"))
					; reset British dict on loading file
	      (add-hook 'find-file-hooks
			'(lambda ()
			   (ispell-change-dictionary "british")))
					; if we are editing text turn on flyspell mode
	      (add-hook 'text-mode-hook 'flyspell-mode))
	  (message "Skipping ispell")))))

;; calculator
;
; If we have the calculator library available lets load it in
;

(if (locate-library "calculator")
    (progn
     (autoload 'calculator "calculator"
      "Run the Emacs calculator." t)
     (global-set-key [(control return)] 'calculator)))

;; Compile Mode Stuff
;
; I want to be able to search straight from the compile mode window
;
; I've tried doing stuff with compile-/compile+ but never got it to work.

(if (locate-library "compile")
    (progn
      (autoload 'compile "compile")
      (autoload 'recompile "compile")
      
      ; ensure the default compile command is sensible
      (setq compile-command (format "cd %s && make -k" current-project-root))
      ; Some keybindsings for compile-command and recompile
      (global-set-key (kbd "C-c c") 'compile)
      (global-set-key (kbd "<f3>")  'compile)
      (global-set-key (kbd "C-c r") 'recompile)
      ; Tweak some variables
      (setq compilation-scroll-output t
      ; compilation-buffer-name-function nil
	    compile-auto-highlight    t
	    compilation-window-height 10)
      (message "Setup compile-mode"))
    (message "Unable to find compile libs..."))

;; Version control library
;
;

(setq vc-command-messages t
      vc-initial-comment t)

; Git Hooks

(if (locate-library "vc-git.el")
    (add-to-list 'vc-handled-backends 'GIT)) 

; Also the git-blame and git-status stuff
(if (locate-library "git")
    (autoload 'git-status "git"
	 "Git Status" t))

(if (locate-library "git-blame")
    (autoload 'git-blame-mode "git-blame"
      "Minor mode for incremental blame for Git." t))

(message "Done GIT hooks")

;; WoMan - WithOut Man
;
; This is mostly handy if you are running on window and you don't have
; man installed.
;

(if (not (which-lookup "man"))
    (if (locate-library "woman")
	(progn
	  (autoload 'woman "woman" "Decode and browse a UN*X man page." t)
	  (autoload 'woman-find-file "woman" "Decode UN*X man-page file." t)
	  (autoload 'woman-dired-find-file "woman" "Browse man page from dired" t)))
  (message "Using man for man pages"))

;; Dired stuff
(add-hook 'dired-mode-hook
		(lambda ()
		  (setq truncate-lines t)))

;;
;; cc-mode stuff
;;
; I'll define all my basic prefs in my-c-style from which the others
; can inherit depending on what I'm working on.
;

(message "Starting cc-mode customisation")

(locate-library "cc-mode")
; Need cc-style

(require 'cc-styles)

(defconst my-c-style
  '((c-tab-always-indent . nil)
    (c-indent-level 3)
    (c-comment-only-line-offset 0)
    (c-basic-offset . 4)
;    (c-echo-syntactic-information-p . t) - this is only useful for debugging
    (c-electric-pound-behavior . (alignleft))
    (c-hanging-comment-ender-p . nil)
    (c-comment-continuation-stars . "* ")
    (c-recognize-knr-p . nil)
    (c-cleanup-list . (empty-defun-braces
		       defun-close-semi
		       list-close-comma
		       scope-operator))
    (c-hanging-braces-alist . ((brace-list-open)
			       (brace-list-close)
			       (block-close . c-snug-do-while)
			       (substatement-open before after)))
    (c-hanging-colons-alist . ((member-init-intro after)
			       (access-label after)
			       (inher-intro after)
			       (case-label after)
			       (label after)))
    (c-offsets-alist . ((arglist-close . c-lineup-arglist)
			(arglist-cont-nonempty . c-lineup-arglist)
			(substatement-open . 0)
			(statement-cont . ++)
;;			(arglist-cont-nonempty . ++)
;		     (ansi-funcdecl-cont . 0)
			(case-label . +)
			(block-open . 0)))
    (indent-tabs-mode . nil)
    )
  "Alex's C style")

(c-add-style "my-c-style" my-c-style)
(setq c-default-style "my-c-style")

;;
;; my-c-mode-hook is called every time
;; I enter c-mode where I can enforce my will
;;
(defun my-c-mode-hook()
  "My c-mode hook"
  (interactive)
  (message "In my-c-mode-hook")
  (turn-on-auto-fill)
  (local-set-key (kbd "<f5>") (lambda (search)
				     (interactive "sSearch C files for:")
				     (my-grep-find
				      current-project-root
				      find-c-files search)))
  ; ensure tab width matches c-basic-offset
  (setq tab-width c-basic-offset)
  (if I-am-emacs-21+
      (cwarn-mode)))
  
(add-hook 'c-mode-common-hook 'my-c-mode-hook)

;;
;; Linux Kernel C-mode
;;
(defun linux-c-mode ()
  "C mode with adjusted defaults for use with the Linux kernel."
  (interactive)
  (c-mode)
  (message "Setting Linux C Style")
  (c-set-style "K&R")
  (setq tab-width 8)
  (setq indent-tabs-mode t)
  (setq c-basic-offset 8))

;; if its got linux in the path then its a kernel file
(setq auto-mode-alist (cons '(".*/linux.*/.*\\.[ch]$" . linux-c-mode)
                       auto-mode-alist))

;;
;; GNU Code
;;
(defun gnu-c-mode ()
  "C mode for GNU stuff"
  (interactive)
  (c-mode)
  (message "Setting Linux C Style")
  (c-set-style "gnu")
  (setq tab-width 8)
  (setq indent-tabs-mode t)
  (setq c-basic-offset 2))
  
(setq auto-mode-alist (cons '(".*binutils.*\\.[ch]$" . gnu-c-mode)
                       auto-mode-alist))

(message "Done with cc-mode customisation")

;;
;; End of c-mode customisations
;;

;; load the ctags library and bind C-f to something worth using :-)
(if (locate-library "etags")
    (progn
      (autoload 'find-tag "etags" "Emacs Tags library" t)
;      (load-library "etags")
      (global-unset-key "\C-f")
      (global-set-key "\C-f" 'find-tag)))


;; CPerl-mode
(setq interpreter-mode-alist (append (list (cons "perl" 'cperl-mode)
					   (cons "perl5" 'cperl-mode)
					   (cons "miniperl" 'cperl-mode))
				     interpreter-mode-alist))

(setq auto-mode-alist (append (list 
			       (cons "\\.\\([pP][Llm]\\|al\\)\\'" 'cperl-mode)
			       (cons "\\.plx\\'" 'cperl-mode)
			       (cons "\\.cgi\\'" 'cperl-mode)
			       (cons "\\.pod\\'" 'cperl-mode)
			       (cons ".*/perl/.*" 'cperl-mode))
			      auto-mode-alist))

(setq cperl-info-on-command-no-prompt nil
      cperl-clobber-lisp-bindings     nil
      cperl-electric-parens           nil
      cperl-electric-keywords         nil)
					 ; cperl-mode tries to load
					 ; abbrev before running the hook

(add-hook 'cperl-mode-hook
	  '(lambda ()
	     (cperl-set-style "BSD")
	     (setq cperl-hairy                                 t
	           cperl-merge-trailing-else                   nil
	           cperl-tab-always-indent                     nil
	           cperl-auto-newline                          nil
	           cperl-electric-lbrace-space                 nil
	           cperl-electric-linefeed                     t
	           cperl-electric-parens                       nil
	           cperl-electric-keywords                     nil
	           cperl-lazy-help-time                        1
	           cperl-extra-newline-before-brace            t
	           cperl-extra-newline-before-brace-multiline  t
	           cperl-max-help-size                         50)
	     (turn-on-auto-fill)
	     (imenu-add-to-menubar "Imenu")
	     (if (not cperl-lazy-installed)	; Only toggle if it's
		 (cperl-toggle-autohelp))	; not already set
	     (if (locate-library "mode-compile")
		 (define-key cperl-mode-map "\C-cr" 'mode-compile))
	     (define-key cperl-mode-map "\C-cc" 'cperl-check-syntax)
	     (define-key cperl-mode-map "\C-j"  'cperl-linefeed)
	     (message "Ran cperl-mode hook")))


;; Elisp mode

; auto-mode lists
(setq auto-mode-alist
      (append (list (cons "\\.emacs\\'" 'emacs-lisp-mode))
	      auto-mode-alist))
; I may also edit as dotemacs
(setq auto-mode-alist
      (append (list (cons "dotemacs" 'emacs-lisp-mode))
	      auto-mode-alist))



(add-hook 'emacs-lisp-mode-hook
	  '(lambda ()
	     (eldoc-mode t)
	     (turn-on-auto-fill)
	     (imenu-add-to-menubar "Imenu")))

;
; Auto-compile my .emacs
;
(defun autocompile nil
  "compile itself if ~/.emacs"
  (interactive)
  (require 'bytecomp)
  (if (string= (buffer-file-name) (expand-file-name (concat default-directory ".emacs")))
      (byte-compile-file (buffer-file-name))))

(add-hook 'after-save-hook 'autocompile)

;; html-helper
;;? See skeleton-insert & auto-insert-alist
;? if new file && /\.hitop$/
;	     (if (eq 0 (string-match "/home/iain/public_html"
;				     buffer-file-name))
;		 (insert "<SET NAME=\"TITLE\"  VALUE=\"Title\">\n"
;			 "<SET NAME=\"BANNER\" VALUE=\"Banner\">\n\n"
;			 "<DEF NAME=\"MAIN\">\n\n</DEF>\n\n"
;			 "<FILE SRC=\"${RELPATH}template.hitop\">\n"))

(if (locate-library "html-helper-mode")
    (progn
      (autoload 'html-helper-mode "html-helper-mode" "Enhanced HTML mode" t)

      (setq auto-mode-alist
	    (append (list (cons "\\.s?html?\\'"  'html-helper-mode))
		    auto-mode-alist))

      (add-hook 'html-helper-load-hook
		'(lambda ()
		   (if (locate-library "html-helper-imenu")
		       (progn
			 (autoload 'html-helper-imenu-setup
			   "html-helper-imenu")
			 (setq html-helper-imenu-title "Imenu")
			 (html-helper-imenu-setup)))

		   (setq tempo-interactive t
			 html-helper-build-new-buffer nil)

		   (defun my-html-helper-timestamp ()
		     (let ((time (current-time-string)))
		       (insert (substring time 4 11)
			       (substring time -4) " ")))
		   (setq html-helper-timestamp-hook 'my-html-helper-timestamp)
		   ))

      (add-hook 'html-helper-mode-hook
		'(lambda ()
		   (setq html-helper-basic-offset 4)
		   
		   (set
		    (make-local-variable 'time-stamp-format)
		    "%:d-%:m-%:y")

		   ;;? Add hitop tags to html-helper-types-to-install?
		   ;;? This looks quite hairy
		   (turn-on-auto-fill)))))

(add-hook 'text-mode-hook
	  '(lambda ()
	     (turn-on-auto-fill)))

(add-hook 'texinfo-mode-hook
	  '(lambda ()
	     (imenu-add-to-menubar "Imenu")))

;; PHP file mode
(if (locate-library "php-mode")
    (progn
      (autoload 'php-mode "php-mode" "PHP mode" t)

      (setq auto-mode-alist
	    (append (list (cons "\\.php[s34]?\\'" 'php-mode))
		    auto-mode-alist))

      ;; colourization
      (add-hook 'php-mode-user-hook 'turn-on-font-lock)))

;; Python Mode
;
; TODO - automode alist
(if (locate-library "python-mode")
    (progn
      (autoload 'python-mode "python-mode")))

(message "Done various programming modes")


;; enable the mouse wheel
(autoload 'mwheel-install "mwheel" "Enable wheely mouse")
(mwheel-install)


;; Convert dos to unix text files
;; from: elf@ee.ryerson.ca (Luis Fernandes)
;; 22 May 1997

;;; Usage: M-x dos2unix
;;;
(defun dos2unix ()
  "Convert this entire buffer from MS-DOS text file format to UNIX."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (replace-regexp "\r$" "" nil)
    (goto-char (1- (point-max)))
    (if (looking-at "\C-z")
        (delete-char 1))))


;; Buffer Selection
;
; The buffer selection library (bs.el) is much more friendly than the default.
; Hence I rebind C-x b to use it.
;
; Configuration can be done with the bs-configurations variable

(if (locate-library "bs")
    (progn
      (autoload 'bs-show "bs")
      (global-set-key (kbd "C-x b") 'bs-show)


      (defun list-buffers-other-win ()
	"Opens list-buffers and put focus on it"
	(interactive)
	(bs-show "all")))

  ; alternative list-buffers-other-win if no bs-show
  ; 1. Ensure focus goes to buffer-list
  ; 2. Make C-g behave like it does in bs-show (i.e. give up)
  (progn
    (defun list-buffers-other-win ()
      "Opens list-buffers and put focus on it"
      (interactive)
      (list-buffers)
      (other-window 1)
      (delete-other-windows)
      (local-set-key (kbd "C-g") 'kill-this-buffer))))

; Make C-x C-b list all buffers, whichever way we frob it
(global-set-key "\C-x\C-b" 'list-buffers-other-win)

(message "Done Buffer Handling Tweaks")

;;
;; Handy little key sequence utility so I don't have to guess at the
;; correct kbd incantation
;;

(defun insert-sequence-key (key)
  "Inserts a keystroke suitable for use in fcns like global-set-key"
  (interactive "kInsert key chord: ")
  (insert (format "(kbd \"%s\")" (key-description key))))

(global-set-key (kbd "<C-f8>") 'insert-sequence-key)

;;
;; Make Bookmark handling a little more sane
;;
;; Rebind from the random octo-keys

(global-set-key [(meta b)] 'list-bookmarks)
(global-set-key [(meta a)] 'bookmark-set)

;; bm.el
;
(if (locate-library "bm")
    (progn
      (autoload 'bm-toggle   "bm" "Toggle bookmark in current buffer." t)
      (autoload 'bm-next     "bm" "Goto bookmark."                     t)
      (autoload 'bm-previous "bm" "Goto previous bookmark." t)

      (global-set-key (kbd "<C-f2>") 'bm-toggle)
      (global-set-key (kbd "<f2>")   'bm-next)
      (global-set-key (kbd "<S-f2>") 'bm-previous)))


;;
;; Macro keys
;;
;; If I define a single press macro keys I may use them more often
;;
(message "Defining Macro Keys")

(global-set-key [(control meta m)] 'call-last-kbd-macro)
(global-set-key (kbd "<f10>") 'call-last-kbd-macro)
(global-set-key (kbd "<C-f11>") 'start-kbd-macro)
(global-set-key (kbd "<C-f12>") 'end-kbd-macro)

;;
;; I have the cedat/ecb stuff on some machines which I'm playing with
;; at the moment
;;
;; This broke when I recursivly added paths. Seeing as I don't use it
;; I'll skip it for the time being
;;
(message "Skipping cedet/ecb")

;(if (locate-library "cedet")
;    (progn
;      (message "Loading cedat stuff....")
;      (load-file (locate-library "cedet"))
;      (require 'speedbar)
;      (require 'cedet)
;      (if (locate-library "ecb")
;	  (progn
;	    (message "Setting up ecb...")
;	    (defvar ecp-options-version "2.32")
;	    (global-set-key (kbd "C-c e") 'ecb-activate)
;	    (autoload 'ecb-activate "ecb")))))
      

;(when (file-exists-p "~/.emacs.d/cedet-1.0pre3/common/cedet.el")
;  (message "Loading cedat stuff....")
;  (load-file "~/.emacs.d/cedet-1.0pre3/common/cedet.el")
;  (add-to-list 'load-path "~/.emacs.d/ecb-2.32/")
;  (defvar ecp-options-version "2.32")
;  (global-set-key (kbd "C-c e") 'ecb-activate)
;  (autoload 'ecb-activate "ecb"))

;  (require 'ecb))

;;
;; rect-mark.el
;;
;; A handy library for marking rectangle areas
;; (currently in ~/.emacs.d)
;;
;; See http://www.emacswiki.org/cgi-bin/wiki/RectangleMark
;;

(if (locate-library "rect-mark")
    (progn
;      (load-library "rect-mark")
      (global-set-key (kbd "C-x r C-SPC") 'rm-set-mark)
      (global-set-key (kbd "C-x r C-x") 'rm-exchange-point-and-mark)
      (global-set-key (kbd "C-x r C-w") 'rm-kill-region)
      (global-set-key (kbd "C-x r M-w") 'rm-kill-ring-save)
      (autoload 'rm-set-mark "rect-mark"
	"Set mark for rectangle." t)
      (autoload 'rm-exchange-point-and-mark "rect-mark"
	"Exchange point and mark for rectangle." t)
      (autoload 'rm-kill-region "rect-mark"
	"Kill a rectangular region and save it in the kill ring." t)
      (autoload 'rm-kill-ring-save "rect-mark"
	"Copy a rectangular region to the kill ring." t)))

;;
;; color-theme
;;
;; Eye-candy! - hmm currently breaks on startup...

(if I-am-emacs-22+
    (if (locate-library "color-theme")
	(progn
	  (load-library "color-theme")
	  (if I-am-in-console
	      (color-theme-dark-laptop)))))

;; Saveplace - Jump to where I last was when I edit a file
;
; Seems to lock up on emacs-snaphsot/22

(unless I-am-emacs-22
  (if (locate-library "saveplace")
      (progn
	(require 'saveplace)
	(setq-default save-place t))))

;;
;; ERC
;;
(if (locate-library "erc")
    (autoload 'erc-select "erc" "Start ERC" t))
;;
;; Desktop, save files and restore
;;

;(desktop-load-default)
;(setq history-length 250)
;(add-to-list 'desktop-globals-to-save 'file-name-history)
;(desktop-read)
;(setq desktop-enable t)

;;
;; I always want my work customisations at work or if I'm running on
;; the VPN at home.
;;

(if (or I-am-at-work (string-match "dynamite" (pwd)))
    (when (file-exists-p "~/.emacs.d/transitive.el")
      (progn
	(message "Loading Work Customistions...")
	(load-file "~/.emacs.d/transitive.el"))))

(message "Done .emacs")

